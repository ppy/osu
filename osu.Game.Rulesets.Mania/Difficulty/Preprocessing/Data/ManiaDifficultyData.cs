// Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.
// See the LICENCE file in the repository root for full licence text.

using System;
using System.Collections.Generic;
using osu.Game.Rulesets.Mania.Difficulty.Preprocessing.DifficultyPreprocessing;
using osu.Game.Rulesets.Mania.Difficulty.Preprocessing.UtilityPreprocessing;

namespace osu.Game.Rulesets.Mania.Difficulty.Preprocessing.Data
{
    /// <summary>
    /// Central context object for Mania difficulty calculation.
    /// Contains all precomputed data and features used during star rating computation.
    /// </summary>
    public class ManiaDifficultyData
    {
        /// <summary>
        /// All hit objects in the beatmap section being processed.
        /// </summary>
        public List<ManiaDifficultyHitObject> AllNotes { get; set; } = new List<ManiaDifficultyHitObject>();

        /// <summary>
        /// Subset of hit objects that are long notes (hold notes).
        /// </summary>
        public List<ManiaDifficultyHitObject> LongNotes { get; set; } = new List<ManiaDifficultyHitObject>();

        /// <summary>
        /// End points of long notes (used for release timing analysis).
        /// </summary>
        public List<ManiaDifficultyHitObject> LongNoteTails { get; set; } = new List<ManiaDifficultyHitObject>();

        /// <summary>
        /// Sampling points for difficulty calculation.
        /// </summary>
        public double[] StrainTimePoints { get; set; } = Array.Empty<double>();

        /// <summary>
        /// Density data representing sustained finger pressure from long notes over time.
        /// Generated by <see cref="LongNoteDensityPreprocessor"/>.
        /// </summary>
        public LongNoteDensityData LongNoteDensityData { get; set; } = new LongNoteDensityData
        {
            TimePoints = new[] { 0.0, 0.0 },
            DensityValues = new[] { 0.0 },
        };

        /// <summary>
        /// Hit timing leniency in milliseconds based on Overall Difficulty.
        /// Smaller values indicate stricter timing windows.
        /// </summary>
        public double HitLeniency { get; set; }

        /// <summary>
        /// Number of columns/keys in the current beatmap.
        /// </summary>
        public int KeyCount { get; set; }

        /// <summary>
        /// Maximum time value in the beatmap.
        /// </summary>
        public int MaxTime { get; set; }

        /// <summary>
        /// Difficulty metrics for jack pattern.
        /// </summary>
        public double[] SameColumnPressure { get; set; } = Array.Empty<double>();

        /// <summary>
        /// Difficulty metrics for cross-column coordination patterns.
        /// </summary>
        public double[] CrossColumnPressure { get; set; } = Array.Empty<double>();

        /// <summary>
        /// Difficulty metrics for pressing intensity and timing precision.
        /// </summary>
        public double[] PressingIntensity { get; set; } = Array.Empty<double>();

        /// <summary>
        /// Difficulty penalty for uneven timing patterns (rhythm inconsistency).
        /// </summary>
        public double[] Unevenness { get; set; } = Array.Empty<double>();

        /// <summary>
        /// Difficulty metrics for long note release timing accuracy.
        /// </summary>
        public double[] ReleaseFactor { get; set; } = Array.Empty<double>();

        /// <summary>
        /// Local note density count within timing windows.
        /// </summary>
        public double[] LocalNoteCount { get; set; } = Array.Empty<double>();

        /// <summary>
        /// Number of simultaneously active keys at each time point.
        /// Used for chord complexity analysis.
        /// </summary>
        public double[] ActiveKeyCount { get; set; } = Array.Empty<double>();

        /// <summary>
        /// Detailed map of individual key states (active/inactive) at each sampling point.
        /// First dimension is the time; second dimension is the key index.
        /// Generated by <see cref="CrossColumnPreprocessor.ComputeKeyUsage"/>.
        /// </summary>
        public bool[][]? SharedKeyUsage { get; set; }

        /// <summary>
        /// Samples a difficulty feature value at an arbitrary time using nearest-neighbor interpolation.
        /// </summary>
        /// <param name="time">Time to sample at</param>
        /// <param name="values">Array of feature values indexed by time corners</param>
        /// <returns>Interpolated feature value at the specified time</returns>
        public double SampleFeatureAtTime(double time, double[] values)
        {
            if (StrainTimePoints.Length == 0 || values.Length == 0)
                return 0.0;

            // Clamp to boundaries
            if (time <= StrainTimePoints[0]) return values[0];
            if (time >= StrainTimePoints[^1]) return values[^1];

            int index = Array.BinarySearch(StrainTimePoints, time);

            // Exact match
            if (index >= 0)
                return values[index];

            // Nearest neighbor (floor value)
            int floorIndex = (~index) - 1;
            return values[Math.Clamp(floorIndex, 0, values.Length - 1)];
        }
    }
}
